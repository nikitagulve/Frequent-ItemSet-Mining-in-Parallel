package apriori;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.io.WritableComparable;
import org.apache.hadoop.io.WritableComparator;
import org.apache.hadoop.io.WritableUtils;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Partitioner;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.NLineInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;

/**
 * Creates CandidateSet file which has candidates of size k+1 generated by joining Frequent ItemSets 
 * of size k
 * 
 * @author niki
 */
public class CandidateSetGen {

	/**
	 * Performs self join of Frequent ItemSets of size k by emitting k-1 elements as key along with the 
	 * last element which is used for secodary sort. 
	 * 
	 * @author niki
	 */
	public static class CandidateSetGenMapper extends
			Mapper<Object, Text, KeyPair, Text> {

		List<String> genreSets = new ArrayList<String>();

		// emits key that is composed of first part as elements in the sets
		// except for last and the last element as second part of the key 
		// (used for secondary sort)
		public void map(Object key, Text value, Context context)
				throws IOException, InterruptedException {

			String value_str = value.toString();
			int lastIndex = value_str.lastIndexOf(',');
			String key_str = value_str.substring(0, lastIndex);
			String last_item = value_str.substring(lastIndex + 1,
					value_str.length());
			KeyPair keyPair = new KeyPair(key_str, Integer.parseInt(last_item));
			
			context.write(keyPair, new Text(last_item));
		}
	}

	/**
	 * The ItemSets having same k-1 elements are grouped together and all possible combinations of 
	 * last elements are appended to the k-1 elements. Hence, we get candidates of size k+1
	 * 
	 * @author niki
	 */
	public static class CandidateSetGenReducer extends
			Reducer<KeyPair, Text, Text, Text> {
		//receives keys partitioned by first part and sorted by the last elements of sets
		//computes self join operation, by grouping by the common elements in the set
		//after computing the pairs of last two elements, it append these pairs to the 
		// first part of the keys
		public void reduce(KeyPair key, Iterable<Text> values, Context context)
				throws IOException, InterruptedException {

			StringBuilder candidate;
			List<String> prev = new ArrayList<String>();
			for (Text value : values) {
				for (int i = 0; i < prev.size(); i++) {
					candidate = new StringBuilder(key.getKeyItems().toString());
					candidate.append(",");
					candidate.append(prev.get(i).toString());
					candidate.append(",");
					candidate.append(value);
					context.write(new Text(candidate.toString()), null);
				}
				prev.add(value.toString());
			}
		}
	}

	// Configures the job
	int configureCandidateSetGenJob(Configuration conf, String input,
			String output) throws IOException, InterruptedException,
			ClassNotFoundException {

		conf.setInt(NLineInputFormat.LINES_PER_MAP,1000);
		Job job = new Job(conf, "Candidate ItemSet Generation");
		job.setJarByClass(CandidateSetGen.class);
		job.setInputFormatClass(NLineInputFormat.class);
		job.setMapperClass(CandidateSetGenMapper.class);
		job.setReducerClass(CandidateSetGenReducer.class);
		job.setPartitionerClass(KeyPairPartitioner.class);
		job.setSortComparatorClass(KeyPairComparator.class);
		job.setGroupingComparatorClass(KeyPairGroupComparator.class);
		job.setNumReduceTasks(15);
		job.setOutputKeyClass(Text.class);
		job.setOutputValueClass(Text.class);
		job.setMapOutputKeyClass(KeyPair.class);
		job.setMapOutputValueClass(Text.class);
		FileInputFormat.addInputPath(job, new Path(input));
		FileOutputFormat.setOutputPath(job, new Path(output));

		return job.waitForCompletion(true) ? 0 : 1;
	}
	
	/**
     * Custom Class class to use for Secondary sort
     * 
     * @author niki
     *
     */
    @SuppressWarnings("rawtypes")
	public static class KeyPair implements WritableComparable {
       
    	//Elements to perform group by
    	private String keyItems;

     
        private int lastItem;

        public KeyPair() {

        }

        public String getKeyItems() {
            return keyItems;
        }

        public int getLastItem() {
            return lastItem;
        }

        public KeyPair(String keyItems, int lastItem) {

            this.keyItems = keyItems;
            this.lastItem = lastItem;
        }

        public void write(DataOutput out) throws IOException {

            WritableUtils.writeString(out, keyItems);
            out.writeInt(lastItem);
        }

        /**
         * Read the keyItems and lastItem.
         */
        public void readFields(DataInput in) throws IOException {

        	keyItems = WritableUtils.readString(in);
        	lastItem = in.readInt();
        }

        public int compareTo(Object o) {

        	KeyPair that = (KeyPair) o;
            int c = keyItems.compareTo(that.keyItems);

            if (c != 0)
                return c;

            if (lastItem == that.lastItem)
                return 0;

            return (lastItem > that.lastItem ? 1 : -1);

        }

        // Hash code for the class
        public int hashCode() {
            return (int) (keyItems.hashCode() + lastItem);
        }

        // Override equals to compare keyItems and lastItem for equality
        public boolean equals(Object o) {

        	KeyPair other;
            if (o instanceof KeyPair) {

                other = (KeyPair) o;
            } else
                return false;

            return (keyItems.equalsIgnoreCase(other.keyItems) && (lastItem == other.lastItem));

        }

        public String toString() {

            StringBuilder sb = new StringBuilder();
            sb.append(keyItems);
            sb.append(lastItem);

            return sb.toString();

        }

    }

    /**
     * Partitioner to partition based on the keyItems in the key
     * 
     * @author niki
     *
     */
    public static class KeyPairPartitioner extends Partitioner<KeyPair, Text> {

        public int getPartition(KeyPair key, Text value, int numPartitions) {

            int hash = Math.abs(key.keyItems.hashCode());
            int partition = hash % numPartitions;

            return partition;

        }

    }

    /**
     * Key comparator to compare two keys
     * 
     * @author niki
     *
     */
    public static class KeyPairComparator extends WritableComparator {

        protected KeyPairComparator() {
            super(KeyPair.class, true);
        }

        @SuppressWarnings("rawtypes")
		public int compare(WritableComparable k1, WritableComparable k2) {

        	KeyPair ut1 = (KeyPair) k1;
        	KeyPair ut2 = (KeyPair) k2;

            return ut1.compareTo(ut2);
        }
    }

    /**
     * Compare only the keyItems part of the key, so that reduce is called once for each value of
	 * the keyItems.
     */
    public static class KeyPairGroupComparator extends WritableComparator {

        protected KeyPairGroupComparator() {
            super(KeyPair.class, true);
        }

        @SuppressWarnings("rawtypes")
		@Override
        public int compare(WritableComparable k1, WritableComparable k2) {

        	KeyPair ut1 = (KeyPair) k1;
        	KeyPair ut2 = (KeyPair) k2;

            return ut1.getKeyItems().compareTo(ut2.getKeyItems());

        }

    }
}
